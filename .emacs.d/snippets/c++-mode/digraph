# -*- mode: snippet -*-
# name: a class for directed graph
# key: digraph
# --
template <typename T, typename W>
class digraph {
public:
  digraph(T size) {
    adjacencyList.resize(size, vector<T>(0));
    edgeWeights.resize(size, vector<T>(0));
  }


  void addEdge(T v1, T v2) {
    adjacencyList[v1].push_back(v2);
  }


  void addEdge(T v1, T v2, W wt) {
    addEdge(v1, v2);
    edgeWeights[v1].push_back(wt);
  }


   void initEdges() {
    for (T v1 = 0; v1 < adjacencyList.size(); ++v1)
      for (T i = 0; i < adjacencyList[v1].size(); ++i) {
        T v2 = adjacencyList[v1][i];
        W wt = edgeWeights[v1][i];
        edges.push_back({v1, v2, wt});
      }

    sort(edges.begin(), edges.end(), [](vector<T>  e1, vector<T> e2) {
        return e1[2] < e2[2];});
  }
 

  W cost(vector<vector<T> > edges) {
    W sum = 0;
    for (auto edge: edges)
      sum += edge[2];

    return sum;
  }
  

  W cost() {
    return cost(edges);
  }

  void bfs();
  void dfs();
  

  vector<vector<T> > kruskal() {
    vector<vector<T> > mst;
    vector<DisjointSet<T, W>* > ds; 

    for (T v = 0; v < adjacencyList.size(); ++v) 
      ds.push_back(new DisjointSet<T, W>(v));

    for (auto edge: edges) {
      T u = edge[0],
        v = edge[1];

      if (ds[u]->find() != ds[v]->find()) {
        mst.push_back(edge);
        ds[u]->Union(ds[v]);
      }
    }
    return mst;
  }


  W dikstra(T v1, T v2);
  
private:
  vector<vector<T> > adjacencyList, edges;
  vector<vector<W> > edgeWeights;

};

